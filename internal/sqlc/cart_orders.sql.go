// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cart_orders.sql

package sqlc

import (
	"context"
)

const clearCartItems = `-- name: ClearCartItems :exec
DELETE FROM cart_items WHERE cart_id = $1
`

func (q *Queries) ClearCartItems(ctx context.Context, cartID int64) error {
	_, err := q.db.ExecContext(ctx, clearCartItems, cartID)
	return err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (user_id, status, total_cents)
VALUES ($1, 'placed', $2)
RETURNING id
`

type CreateOrderParams struct {
	UserID     int64 `json:"user_id"`
	TotalCents int32 `json:"total_cents"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createOrder, arg.UserID, arg.TotalCents)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createOrderItem = `-- name: CreateOrderItem :exec
INSERT INTO order_items (order_id, product_id, unit_price_cents, qty, line_total_cents)
VALUES ($1, $2, $3, $4, $5)
`

type CreateOrderItemParams struct {
	OrderID        int64 `json:"order_id"`
	ProductID      int64 `json:"product_id"`
	UnitPriceCents int32 `json:"unit_price_cents"`
	Qty            int32 `json:"qty"`
	LineTotalCents int32 `json:"line_total_cents"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) error {
	_, err := q.db.ExecContext(ctx, createOrderItem,
		arg.OrderID,
		arg.ProductID,
		arg.UnitPriceCents,
		arg.Qty,
		arg.LineTotalCents,
	)
	return err
}

const decrementProductStock = `-- name: DecrementProductStock :exec
UPDATE products
SET stock = stock - $2, updated_at = now()
WHERE id = $1 AND stock >= $2
`

type DecrementProductStockParams struct {
	ID    int64 `json:"id"`
	Stock int32 `json:"stock"`
}

func (q *Queries) DecrementProductStock(ctx context.Context, arg DecrementProductStockParams) error {
	_, err := q.db.ExecContext(ctx, decrementProductStock, arg.ID, arg.Stock)
	return err
}

const deleteCartItem = `-- name: DeleteCartItem :exec
DELETE FROM cart_items WHERE id = $1
`

func (q *Queries) DeleteCartItem(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCartItem, id)
	return err
}

const deleteCartItemInCart = `-- name: DeleteCartItemInCart :exec
DELETE FROM cart_items
WHERE id = $1 AND cart_id = $2
`

type DeleteCartItemInCartParams struct {
	ID     int64 `json:"id"`
	CartID int64 `json:"cart_id"`
}

func (q *Queries) DeleteCartItemInCart(ctx context.Context, arg DeleteCartItemInCartParams) error {
	_, err := q.db.ExecContext(ctx, deleteCartItemInCart, arg.ID, arg.CartID)
	return err
}

const getActiveCartID = `-- name: GetActiveCartID :one
SELECT id
FROM carts
WHERE user_id = $1 AND status = 'active'
LIMIT 1
`

func (q *Queries) GetActiveCartID(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getActiveCartID, userID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getOrCreateActiveCart = `-- name: GetOrCreateActiveCart :one
WITH existing AS (
  SELECT c.id FROM carts c WHERE c.user_id = $1 AND c.status = 'active' LIMIT 1
),
inserted AS (
  INSERT INTO carts (user_id, status)
  SELECT $1, 'active'
  WHERE NOT EXISTS (SELECT 1 FROM existing)
  RETURNING id
)
SELECT id FROM inserted
UNION ALL
SELECT id FROM existing
LIMIT 1
`

func (q *Queries) GetOrCreateActiveCart(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getOrCreateActiveCart, userID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const listCartItems = `-- name: ListCartItems :many
SELECT
  ci.id,
  ci.product_id,
  ci.qty,
  p.name,
  (p.price_cents::int) AS price_cents,
  (p.price_cents::int * ci.qty)::int AS line_total_cents
FROM cart_items ci
JOIN products p ON p.id = ci.product_id
WHERE ci.cart_id = $1
ORDER BY ci.id
`

type ListCartItemsRow struct {
	ID             int64  `json:"id"`
	ProductID      int64  `json:"product_id"`
	Qty            int32  `json:"qty"`
	Name           string `json:"name"`
	PriceCents     int32  `json:"price_cents"`
	LineTotalCents int32  `json:"line_total_cents"`
}

func (q *Queries) ListCartItems(ctx context.Context, cartID int64) ([]ListCartItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCartItems, cartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCartItemsRow
	for rows.Next() {
		var i ListCartItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Qty,
			&i.Name,
			&i.PriceCents,
			&i.LineTotalCents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockCartItemsForCheckout = `-- name: LockCartItemsForCheckout :many
SELECT ci.product_id, ci.qty, p.price_cents, p.stock, p.is_active
FROM cart_items ci
JOIN products p ON p.id = ci.product_id
WHERE ci.cart_id = $1
FOR UPDATE
`

type LockCartItemsForCheckoutRow struct {
	ProductID  int64   `json:"product_id"`
	Qty        int32   `json:"qty"`
	PriceCents float64 `json:"price_cents"`
	Stock      int32   `json:"stock"`
	IsActive   bool    `json:"is_active"`
}

func (q *Queries) LockCartItemsForCheckout(ctx context.Context, cartID int64) ([]LockCartItemsForCheckoutRow, error) {
	rows, err := q.db.QueryContext(ctx, lockCartItemsForCheckout, cartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LockCartItemsForCheckoutRow
	for rows.Next() {
		var i LockCartItemsForCheckoutRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Qty,
			&i.PriceCents,
			&i.Stock,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markCartCheckedOut = `-- name: MarkCartCheckedOut :exec
UPDATE carts
SET status = 'checked_out', updated_at = now()
WHERE id = $1
`

func (q *Queries) MarkCartCheckedOut(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markCartCheckedOut, id)
	return err
}

const updateCartItemQty = `-- name: UpdateCartItemQty :exec
UPDATE cart_items
SET qty = $2, updated_at = now()
WHERE id = $1
`

type UpdateCartItemQtyParams struct {
	ID  int64 `json:"id"`
	Qty int32 `json:"qty"`
}

func (q *Queries) UpdateCartItemQty(ctx context.Context, arg UpdateCartItemQtyParams) error {
	_, err := q.db.ExecContext(ctx, updateCartItemQty, arg.ID, arg.Qty)
	return err
}

const updateCartItemQtyInCart = `-- name: UpdateCartItemQtyInCart :exec
UPDATE cart_items
SET qty = $3, updated_at = now()
WHERE id = $1 AND cart_id = $2
`

type UpdateCartItemQtyInCartParams struct {
	ID     int64 `json:"id"`
	CartID int64 `json:"cart_id"`
	Qty    int32 `json:"qty"`
}

func (q *Queries) UpdateCartItemQtyInCart(ctx context.Context, arg UpdateCartItemQtyInCartParams) error {
	_, err := q.db.ExecContext(ctx, updateCartItemQtyInCart, arg.ID, arg.CartID, arg.Qty)
	return err
}

const upsertCartItem = `-- name: UpsertCartItem :one
INSERT INTO cart_items (cart_id, product_id, qty)
VALUES ($1, $2, $3)
ON CONFLICT (cart_id, product_id)
DO UPDATE SET qty = cart_items.qty + EXCLUDED.qty, updated_at = now()
RETURNING id, cart_id, product_id, qty
`

type UpsertCartItemParams struct {
	CartID    int64 `json:"cart_id"`
	ProductID int64 `json:"product_id"`
	Qty       int32 `json:"qty"`
}

type UpsertCartItemRow struct {
	ID        int64 `json:"id"`
	CartID    int64 `json:"cart_id"`
	ProductID int64 `json:"product_id"`
	Qty       int32 `json:"qty"`
}

func (q *Queries) UpsertCartItem(ctx context.Context, arg UpsertCartItemParams) (UpsertCartItemRow, error) {
	row := q.db.QueryRowContext(ctx, upsertCartItem, arg.CartID, arg.ProductID, arg.Qty)
	var i UpsertCartItemRow
	err := row.Scan(
		&i.ID,
		&i.CartID,
		&i.ProductID,
		&i.Qty,
	)
	return i, err
}
